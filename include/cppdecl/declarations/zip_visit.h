#pragma once

#include "cppdecl/declarations/data.h"
#include "cppdecl/misc/platform.h"

#include <cstddef>
#include <utility>

// This lets you visit two entities in parallel, zipping them.
// Currently we silently stop the recursion on hierarchy mismatch.

namespace cppdecl
{
    // Some declarations necessary for recursion: [
    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(PseudoExpr &a, PseudoExpr &b, auto &&func);
    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(QualifiedName &a, QualifiedName &b, auto &&func);
    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(Type &a, Type &b, auto &&func);
    // ]


    // Declares the three other overload for every function in this file.
    // `(T &, T &)` is written manually, while the other three are generated by this macro: `(T &, const T &)`, `(const T &, T &)`, `(const T &, const T &)`.
    #define DETAIL_CPPDECL_MAKE_CONST_OVERLOADS(T) \
        CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(T &a, const T &b, auto &&func) \
        {(ZipVisitSimpleTypes)(a, const_cast<T &>(b), [func = decltype(func)(func)](auto &a, auto &b){func(a, std::as_const(b));});} \
        CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(const T &a, T &b, auto &&func) \
        {(ZipVisitSimpleTypes)(const_cast<T &>(a), b, [func = decltype(func)(func)](auto &a, auto &b){func(std::as_const(a), b);});} \
        CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(const T &a, const T &b, auto &&func) \
        {(ZipVisitSimpleTypes)(const_cast<T &>(a), const_cast<T &>(b), [func = decltype(func)(func)](auto &a, auto &b){func(std::as_const(a), std::as_const(b));});}


    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(SimpleType &a, SimpleType &b, auto &&func)
    {
        // Just call directly.
        func(a, b);
    }
    DETAIL_CPPDECL_MAKE_CONST_OVERLOADS(SimpleType)

    // The stubs here and below can just be `const`, without the `DETAIL_CPPDECL_MAKE_CONST_OVERLOADS` macro, since we don't call the passed callback anyway.
    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(const PunctuationToken &, const PunctuationToken &, auto &&) {}
    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(const NumericLiteral &, const NumericLiteral &, auto &&) {}
    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(const StringOrCharLiteral &, const StringOrCharLiteral &, auto &&) {}

    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(PseudoExprList &a, PseudoExprList &b, auto &&func)
    {
        // Ignoring `.has_trailing_comma` here, as it's purely decorative.
        if (a.kind == b.kind && a.elems.size() == b.elems.size())
        {
            for (std::size_t i = 0; i < a.elems.size(); i++)
            {
                (ZipVisitSimpleTypes)(a.elems[i], b.elems[i], func);
            }
        }
    }
    DETAIL_CPPDECL_MAKE_CONST_OVERLOADS(PseudoExprList)

    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(TemplateArgumentList &a, TemplateArgumentList &b, auto &&func)
    {
        if (a.args.size() == b.args.size())
        {
            for (std::size_t i = 0; i < a.args.size(); i++)
            {
                (ZipVisitSimpleTypes)(a.args[i], b.args[i], func);
            }
        }
    }
    DETAIL_CPPDECL_MAKE_CONST_OVERLOADS(TemplateArgumentList)

    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(Decl &a, Decl &b, auto &&func)
    {
        // Should we make one of those conditional? It probably doesn't matter, and I'm not sure which one anyway.
        (ZipVisitSimpleTypes)(a.type, b.type, func);
        (ZipVisitSimpleTypes)(a.name, b.name, func);
    }
    DETAIL_CPPDECL_MAKE_CONST_OVERLOADS(Decl)

    // Do I want to recurse into `MaybeAmbiguous<T>`?
    // At one hand I don't really need it, but on the other it would be confusing if I didn't?
    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(MaybeAmbiguousDecl &a, MaybeAmbiguousDecl &b, auto &&func)
    {
        (ZipVisitSimpleTypes)(static_cast<Decl &>(a), static_cast<Decl &>(b), func);
        if (bool(a.ambiguous_alternative) == bool(b.ambiguous_alternative))
            (ZipVisitSimpleTypes)(*a.ambiguous_alternative, *b.ambiguous_alternative, func);
    }
    DETAIL_CPPDECL_MAKE_CONST_OVERLOADS(MaybeAmbiguousDecl)

    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(const Pointer &, const Pointer &, auto &&) {}
    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(const Reference &, const Reference &, auto &&) {}

    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(MemberPointer &a, MemberPointer &b, auto &&func)
    {
        (ZipVisitSimpleTypes)(a.base, b.base, func);
    }
    DETAIL_CPPDECL_MAKE_CONST_OVERLOADS(MemberPointer)

    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(const Array &, const Array &, auto &&) {}

    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(Function &a, Function &b, auto &&func)
    {
        // Here I ignore some decorative parameters.

        if (a.cv_quals == b.cv_quals && a.ref_qual == b.ref_qual && a.noexcept_ == b.noexcept_ && a.c_style_variadic == b.c_style_variadic && a.params.size() == b.params.size())
        {
            for (std::size_t i = 0; i < a.params.size(); i++)
            {
                (ZipVisitSimpleTypes)(a.params[i], b.params[i], func);
            }
        }
    }
    DETAIL_CPPDECL_MAKE_CONST_OVERLOADS(Function)

    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(TypeModifier &a, TypeModifier &b, auto &&func)
    {
        std::visit(
            [&]<typename T>(T &a_elem)
            {
                if (auto b_elem = std::get_if<T>(&b.var))
                {
                    (ZipVisitSimpleTypes)(a_elem, *b_elem, func);
                }
            },
            a.var
        );
    }
    DETAIL_CPPDECL_MAKE_CONST_OVERLOADS(TypeModifier)

    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(Type &a, Type &b, auto &&func)
    {
        if (a.modifiers.size() == b.modifiers.size())
        {
            // Definitely visit modifiers first, because we want to continue only if we end up making them equal. I think?
            for (std::size_t i = 0; i < a.modifiers.size(); i++)
            {
                (ZipVisitSimpleTypes)(a.modifiers[i], a.modifiers[i], func);
            }

            if (a.modifiers == b.modifiers) // I guess?
            {
                (ZipVisitSimpleTypes)(a.simple_type, b.simple_type, func);
            }
        }
    }
    DETAIL_CPPDECL_MAKE_CONST_OVERLOADS(Type)

    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(PseudoExpr &a, PseudoExpr &b, auto &&func)
    {
        if (a.tokens.size() == b.tokens.size())
        {
            for (std::size_t i = 0; i < a.tokens.size(); i++)
            {
                std::visit(
                    [&]<typename T>(T &a_elem)
                    {
                        if (auto b_elem = std::get_if<T>(&b.tokens[i]))
                        {
                            (ZipVisitSimpleTypes)(a_elem, *b_elem, func);
                        }
                    },
                    a.tokens[i]
                );
            }
        }
    }
    DETAIL_CPPDECL_MAKE_CONST_OVERLOADS(PseudoExpr)

    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(TemplateArgument &a, TemplateArgument &b, auto &&func)
    {
        std::visit(
            [&]<typename T>(T &a_elem)
            {
                if (auto b_elem = std::get_if<T>(&b.var))
                {
                    (ZipVisitSimpleTypes)(a_elem, *b_elem, func);
                }
            },
            a.var
        );
    }
    DETAIL_CPPDECL_MAKE_CONST_OVERLOADS(TemplateArgument)

    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(UnqualifiedName &a, UnqualifiedName &b, auto &&func)
    {
        if (a.var == b.var && bool(a.template_args) == bool(b.template_args) && a.template_args->args.size() == b.template_args->args.size())
        {
            for (std::size_t i = 0; i < a.template_args->args.size(); i++)
            {
                (ZipVisitSimpleTypes)(a.template_args->args[i], b.template_args->args[i], func);
            }
        }
    }
    DETAIL_CPPDECL_MAKE_CONST_OVERLOADS(UnqualifiedName)

    CPPDECL_CONSTEXPR void ZipVisitSimpleTypes(QualifiedName &a, QualifiedName &b, auto &&func)
    {
        if (a.force_global_scope == b.force_global_scope && a.parts.size() == b.parts.size())
        {
            for (std::size_t i = 0; i < a.parts.size(); i++)
            {
                (ZipVisitSimpleTypes)(a.parts[i], b.parts[i], func);
            }
        }
    }
    DETAIL_CPPDECL_MAKE_CONST_OVERLOADS(QualifiedName)

    #undef DETAIL_CPPDECL_MAKE_CONST_OVERLOADS
}
